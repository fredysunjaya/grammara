{"version":3,"sources":["../src/index.ts"],"sourcesContent":["// When bundled via a bundler supporting the `browser` field, then\n// the `undici` module will be replaced with https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\n// for browser contexts. See ./undici-browser.js and ./package.json\nimport { fetch } from 'undici';\nimport type { BlobCommandOptions } from './helpers';\nimport {\n  getApiUrl,\n  getApiVersionHeader,\n  getTokenFromOptionsOrEnv,\n  validateBlobApiResponse,\n} from './helpers';\nimport type { PutCommandOptions } from './put';\nimport { createPutMethod } from './put';\n\n// expose the BlobError types\nexport {\n  BlobAccessError,\n  BlobError,\n  BlobUnknownError,\n  BlobStoreNotFoundError,\n  BlobStoreSuspendedError,\n  BlobNotFoundError,\n} from './helpers';\nexport type { PutBlobResult } from './put';\n\n// vercelBlob.put()\nexport const put = createPutMethod<PutCommandOptions>({\n  allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n});\n\n// vercelBlob.del()\n\ntype DeleteBlobApiResponse = null;\n\n// del accepts either a single url or an array of urls\n// we use function overloads to define the return type accordingly\nexport async function del(\n  url: string[] | string,\n  options?: BlobCommandOptions\n): Promise<void> {\n  const blobApiResponse = await fetch(getApiUrl('/delete'), {\n    method: 'POST',\n    headers: {\n      ...getApiVersionHeader(),\n      authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`,\n      'content-type': 'application/json',\n    },\n    body: JSON.stringify({ urls: Array.isArray(url) ? url : [url] }),\n  });\n\n  await validateBlobApiResponse(blobApiResponse);\n\n  (await blobApiResponse.json()) as DeleteBlobApiResponse;\n}\n\n// vercelBlob.head()\n\nexport interface HeadBlobResult {\n  url: string;\n  size: number;\n  uploadedAt: Date;\n  pathname: string;\n  contentType: string;\n  contentDisposition: string;\n  cacheControl: string;\n}\n\ninterface HeadBlobApiResponse extends Omit<HeadBlobResult, 'uploadedAt'> {\n  uploadedAt: string; // when receiving data from our API, uploadedAt is a string\n}\n\nexport async function head(\n  url: string,\n  options?: BlobCommandOptions\n): Promise<HeadBlobResult> {\n  const headApiUrl = new URL(getApiUrl());\n  headApiUrl.searchParams.set('url', url);\n\n  const blobApiResponse = await fetch(headApiUrl, {\n    method: 'GET', // HEAD can't have body as a response, so we use GET\n    headers: {\n      ...getApiVersionHeader(),\n      authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`,\n    },\n  });\n\n  await validateBlobApiResponse(blobApiResponse);\n\n  const headResult = (await blobApiResponse.json()) as HeadBlobApiResponse;\n\n  return mapBlobResult(headResult);\n}\n\n// vercelBlob.list()\ninterface ListBlobResultBlob {\n  url: string;\n  pathname: string;\n  size: number;\n  uploadedAt: Date;\n}\n\nexport interface ListBlobResult {\n  blobs: ListBlobResultBlob[];\n  cursor?: string;\n  hasMore: boolean;\n}\n\ninterface ListBlobApiResponseBlob\n  extends Omit<ListBlobResultBlob, 'uploadedAt'> {\n  uploadedAt: string;\n}\n\ninterface ListBlobApiResponse extends Omit<ListBlobResult, 'blobs'> {\n  blobs: ListBlobApiResponseBlob[];\n}\n\nexport interface ListCommandOptions extends BlobCommandOptions {\n  limit?: number;\n  prefix?: string;\n  cursor?: string;\n}\n\nexport async function list(\n  options?: ListCommandOptions\n): Promise<ListBlobResult> {\n  const listApiUrl = new URL(getApiUrl());\n  if (options?.limit) {\n    listApiUrl.searchParams.set('limit', options.limit.toString());\n  }\n  if (options?.prefix) {\n    listApiUrl.searchParams.set('prefix', options.prefix);\n  }\n  if (options?.cursor) {\n    listApiUrl.searchParams.set('cursor', options.cursor);\n  }\n  const blobApiResponse = await fetch(listApiUrl, {\n    method: 'GET',\n    headers: {\n      ...getApiVersionHeader(),\n      authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`,\n    },\n  });\n\n  await validateBlobApiResponse(blobApiResponse);\n\n  const results = (await blobApiResponse.json()) as ListBlobApiResponse;\n\n  return {\n    ...results,\n    blobs: results.blobs.map(mapBlobResult),\n  };\n}\n\nfunction mapBlobResult(blobResult: HeadBlobApiResponse): HeadBlobResult;\nfunction mapBlobResult(blobResult: ListBlobApiResponseBlob): ListBlobResultBlob;\nfunction mapBlobResult(\n  blobResult: ListBlobApiResponseBlob | HeadBlobApiResponse\n): ListBlobResultBlob | HeadBlobResult {\n  return {\n    ...blobResult,\n    uploadedAt: new Date(blobResult.uploadedAt),\n  };\n}\n"],"mappings":";;;;;;;;;;;;;;;AAGA,SAAS,aAAa;AAuBf,IAAM,MAAM,gBAAmC;AAAA,EACpD,gBAAgB,CAAC,sBAAsB,mBAAmB,aAAa;AACzE,CAAC;AAQD,eAAsB,IACpB,KACA,SACe;AACf,QAAM,kBAAkB,MAAM,MAAM,UAAU,SAAS,GAAG;AAAA,IACxD,QAAQ;AAAA,IACR,SAAS;AAAA,MACP,GAAG,oBAAoB;AAAA,MACvB,eAAe,UAAU,yBAAyB,OAAO;AAAA,MACzD,gBAAgB;AAAA,IAClB;AAAA,IACA,MAAM,KAAK,UAAU,EAAE,MAAM,MAAM,QAAQ,GAAG,IAAI,MAAM,CAAC,GAAG,EAAE,CAAC;AAAA,EACjE,CAAC;AAED,QAAM,wBAAwB,eAAe;AAE7C,EAAC,MAAM,gBAAgB,KAAK;AAC9B;AAkBA,eAAsB,KACpB,KACA,SACyB;AACzB,QAAM,aAAa,IAAI,IAAI,UAAU,CAAC;AACtC,aAAW,aAAa,IAAI,OAAO,GAAG;AAEtC,QAAM,kBAAkB,MAAM,MAAM,YAAY;AAAA,IAC9C,QAAQ;AAAA;AAAA,IACR,SAAS;AAAA,MACP,GAAG,oBAAoB;AAAA,MACvB,eAAe,UAAU,yBAAyB,OAAO;AAAA,IAC3D;AAAA,EACF,CAAC;AAED,QAAM,wBAAwB,eAAe;AAE7C,QAAM,aAAc,MAAM,gBAAgB,KAAK;AAE/C,SAAO,cAAc,UAAU;AACjC;AA+BA,eAAsB,KACpB,SACyB;AACzB,QAAM,aAAa,IAAI,IAAI,UAAU,CAAC;AACtC,MAAI,mCAAS,OAAO;AAClB,eAAW,aAAa,IAAI,SAAS,QAAQ,MAAM,SAAS,CAAC;AAAA,EAC/D;AACA,MAAI,mCAAS,QAAQ;AACnB,eAAW,aAAa,IAAI,UAAU,QAAQ,MAAM;AAAA,EACtD;AACA,MAAI,mCAAS,QAAQ;AACnB,eAAW,aAAa,IAAI,UAAU,QAAQ,MAAM;AAAA,EACtD;AACA,QAAM,kBAAkB,MAAM,MAAM,YAAY;AAAA,IAC9C,QAAQ;AAAA,IACR,SAAS;AAAA,MACP,GAAG,oBAAoB;AAAA,MACvB,eAAe,UAAU,yBAAyB,OAAO;AAAA,IAC3D;AAAA,EACF,CAAC;AAED,QAAM,wBAAwB,eAAe;AAE7C,QAAM,UAAW,MAAM,gBAAgB,KAAK;AAE5C,SAAO;AAAA,IACL,GAAG;AAAA,IACH,OAAO,QAAQ,MAAM,IAAI,aAAa;AAAA,EACxC;AACF;AAIA,SAAS,cACP,YACqC;AACrC,SAAO;AAAA,IACL,GAAG;AAAA,IACH,YAAY,IAAI,KAAK,WAAW,UAAU;AAAA,EAC5C;AACF;","names":[]}